#Primero las dependencias:
library(magrittr)
library(dplyr)
library(tidyr)
library(stringr)
library(tibble)
library(purrr)
library(sf)
library(ggplot2)
library(patchwork)
library(viridis)
library(rstudioapi)
library(systemfonts)
library(ggspatial)

#Taxa Richness

.admin_repot = c( "UTM_grid","Subprovince", "Country", "Constituent_Country_OR_Crown_Dependency", "Admin_units_II", "Admin_units_III", "National_Nature_Reserve_Name", "Natura_2000_Name")

.taxa_richness = c("Phylum", "Subphylum", "Order", "Family", "Genus", "Species_with_Author")


#' @title Taxa richness of Celtic Invasive Plants database or selections (Taxa_Rich_CIPdb)
#' @description  This function estimates the taxa richness given a taxonomic scope and an area scope.
#' @param 'data' argument must be the table obtained from CIPdb() or another selection of this (Select_CIPdb, WDPA_PID_select_CIPdb).
#' @param 'Scope_taxa' must be be either a character string or a vector of character strings. It must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author.
#' @param 'Scope_Area' must be be either a character string or a vector of character strings. It must be one of these: UTM_grid, Subprovince, Country, Constituent_Country_OR_Crown_Dependency, Admin_units_II, Admin_units_III, National_Nature_Reserve_Name, and Natura_2000_Name.
#' @param 'output_name' this parameter only works when the function is fed with more than one string for the 'Scope_Area'  parameter. This will be the common name given to the different tables generated by this function. This common name will be followed by one of the values fed in 'Scope_Area'  parameter.
#' This is automatically set to "Taxa_Richness", but this name can be changed by the user.
#' @return  This function returns a table in which one column corresponds to the different values of the 'Scope_Area' values of the 'data' and column(s) named after the Scope_taxa values (e.g. if  the Scope_taxa velum is Phylum, this would be named as Phylum_richness) dealing the number of different elements found in this column in the input 'data'.
#' If this function is fed with more than one element in Scope_Area', it will automatically generate a table per each different value. If the Scope_Area is set to "UTM_grid", the columns for the Latitude and Longitude of the coordinates of the centroids of this 10x10 km grid will be included in the retrieved table.
#' @details The optimal way of using this function is in combination with the  Select_CIPdb() or WDPA_PID_select_CIPdb() functions.
#' @examples
#'
#'
#'#This provides the taxa richness of Family Genus and species in the UTM_grid of France.
#'
#' Data = CIPdb()
#' My_selection <- Select_CIPdb(Data, query = "France")
#' My_taxa_scope = c("Family", "Genus", "Species_with_Author")
#' My_tax_rich = Taxa_Rich_CIPdb(My_selection, My_taxa_scope , "UTM_grid")
#'
#' #This provides Genera and Species Richness of  in the Subprovinces, National_Nature_Reserve_Name, and Natura_2000_Name  of France  and Spain
#' Data = CIPdb()
#' My_selection <- Select_CIPdb(Data, query = c("France", "Spain"))
#' My_areas  = c("Subprovince", "National_Nature_Reserve_Name", "Natura_2000_Name")
#' My_taxa_scope = c("Genus", "Species_with_Author")
#' My_tax_rich = Taxa_Rich_CIPdb(My_selection, My_taxa_scope , My_areas, output_name = "Spain_France_Species_Genus_Richness")
#'
#' @export

Taxa_Rich_CIPdb  <- function(data, Scope_taxa, Scope_Area, output_name = "Taxa_Richness") {
  if (!all(Scope_taxa %in% .taxa_richness)) {
    stop(paste0("Scope_taxa must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author. These values are not valid: ", paste(setdiff(Scope_taxa, .taxa_richness), collapse = ", ")))
  }

  if (!all(Scope_Area %in% c(.admin_repot, "UTM_grid"))) {
    stop(paste0("Scope_Area must be one of these: Subprovince, Country, Constituent_Country_OR_Crown_Dependency, Admin_units_II, Admin_units_III, National_Nature_Reserve_Name, Natura_2000_Name or UTM_grid. These values are not valid: ", paste(setdiff(Scope_Area, c(.admin_repot, "UTM_grid")), collapse = ", ")))
  }

  result_list <- map(Scope_Area, function(area) {
    if (area == "UTM_grid") {
      result <- data %>%
        filter(!is.na(!!sym(area))) %>%
        group_by(!!sym(area)) %>%
        summarise(
          Latitude = mean(Latitude, na.rm = TRUE),
          Longitude = mean(Longitude, na.rm = TRUE),
          across(all_of(Scope_taxa), ~ n_distinct(.[. != "" & !is.na(.) & !is.nan(.)]))
        )
      cols_to_rename <- intersect(names(result), Scope_taxa)
      names(result)[names(result) %in% cols_to_rename] <- paste0(cols_to_rename, "_richness")
    } else {
      result <- data %>%
        filter(!is.na(!!sym(area))) %>%
        group_by(!!sym(area)) %>%
        summarise(
          across(all_of(Scope_taxa), ~ n_distinct(.[. != "" & !is.na(.) & !is.nan(.)]))
        )
      names(result)[-1] <- paste0(names(result)[-1], "_richness")
    }
    result
  })

  names(result_list) <- paste0(output_name, "_", Scope_Area)

  if (length(Scope_Area) == 1) {
    return(result_list[[1]])
  } else {
    list2env(result_list, envir = .GlobalEnv)
  }
}


#Primero cargamos la lista con toes les cuadrícules per valor

.occup_db =  read.csv(system.file("extdata", "DB_V6_APRIL_2025_OCCUP_UTM_grids_V1.csv", package = "CelticInvasivePlantsdb"),
                      header = TRUE, sep = "\t", stringsAsFactors = FALSE)

.admin_scope_occup = c("Subprovince", "Country", "Constituent_Country_OR_Crown_Dependency", "Admin_units_II", "Admin_units_III", "National_Nature_Reserve_Name", "Natura_2000_Name")


#' @title Taxa occupation of Celtic Invasive Plants database or selections (Taxa_Occup_CIPdb)
#' @description  This function estimates the percentage of taxa occupation given a taxonomic scope and an area scope.
#' @param 'data' argument must be the table obtained from CIPdb() or another selection of this (Select_CIPdb, WDPA_PID_select_CIPdb).
#' @param 'Scope_taxa' must be be either a character string or a vector of character strings. It must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author.
#' @param 'Scope_Area' must be be either a character string or a vector of character strings. It must be one of these: UTM_grid, Subprovince, Country, Constituent_Country_OR_Crown_Dependency, Admin_units_II, Admin_units_III, National_Nature_Reserve_Name, and Natura_2000_Name.
#' @param 'output_name' this parameter only works when the function is fed with more than one string for the 'Scope_Area'  parameter. This will be the common name given to the different tables generated by this function. This common name will be followed by one of the values fed in 'Scope_Area'  parameter.
#' This is automatically set to "Taxa_Occupation", but this name can be changed by the user.
#' @return  This function returns a table in which one column corresponds to the different values of the 'Scope_Area' values of the 'data' and column(s) named after the Scope_taxa values (e.g. if  the Scope_taxa value is Phylum, this would be named as Phylum_richness) dealing the number of different elements found in this column in the input 'data'.
#' If this function is fed with more than one element in Scope_Area', it will automatically generate a table per each different value. If the Scope_Area is set to "UTM_grid", the columns for the Latitude and Longitude of the coordinates of the centroids of this 10x10 km grid will be included in the retrieved table.
#' @details The optimal way of using this function is in combination with the  Select_CIPdb() or WDPA_PID_select_CIPdb() functions.
#' @examples
#'
#'#This provides the taxa richness of Family Genus and species in the UTM_grid of France.
#'
#' Data = CIPdb()
#'
#' My_taxa_scope = c("Family", "Genus", "Species_with_Author")
#' My_tax_occup = Taxa_Occup_CIPdb(Data, My_taxa_scope , "Country")
#'
#' #This provides Genera and Species Richness of  in the Subprovinces, National_Nature_Reserve_Name, and Natura_2000_Name  of France  and Spain
#' Data = CIPdb()
#' My_selection <- Select_CIPdb(Data, query = c("France", "Spain"))
#' My_areas  = c("Subprovince", "National_Nature_Reserve_Name", "Natura_2000_Name")
#' My_taxa_scope = c("Genus", "Species_with_Author")
#' My_tax_occup = Taxa_Occup_CIPdb(My_selection, My_taxa_scope , My_areas, output_name = "Spain_France_Species_Genus_Occupation")
#'
#'
#' #This generates the occupation of the species of the genus Cotoneaster
#' My_selection <- Select_CIPdb(Data, query = "Cotoneaster")
#' My_areas  = c("Subprovince", "National_Nature_Reserve_Name", "Natura_2000_Name")
#' My_taxa_scope = c("Genus", "Species_with_Author")
#' My_tax_occup = Taxa_Occup_CIPdb(My_selection, My_taxa_scope , My_areas, output_name = "Cotoneaster_Species_Genus_Occupation")
#'
#' @export
Taxa_Occup_CIPdb <- function(data, Scope_taxa, Scope_Area, output_name = "Taxa_Occupation") {
  if (!all(Scope_taxa %in% .taxa_richness)) {
    stop(paste0("Scope_taxa must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author. These values are not valid: ", paste(setdiff(Scope_taxa, .taxa_richness), collapse = ", ")))
  }
  if (!all(Scope_Area %in% .admin_scope_occup)) {
    stop(paste0("Scope_Area must be one of these: Subprovince, Country, Constituent_Country_OR_Crown_Dependency, Admin_units_II, Admin_units_III, National_Nature_Reserve_Name or Natura_2000_Name. These values are not valid: ", paste(setdiff(Scope_Area, .admin_scope_occup), collapse = ", ")))
  }

  result_list <- map(Scope_Area, function(area) {
    result <- data %>%
      filter(!is.na(!!sym(area))) %>%
      group_by(!!sym(area)) %>%
      summarise(
        across(all_of(Scope_taxa), ~ length(unique(UTM_grid[. != "" & !is.na(.) & !is.nan(.)])))
      )
    names(result)[-1] <- paste0(names(result)[-1], "_occupation")

    # Agregar columna de porcentaje
    for (taxon in Scope_taxa) {
      occup_col <- paste0(taxon, "_occupation")
      percent_col <- paste0(taxon, "_occupation_percentage")
      area_values <- unique(result[[area]])
      occup_db_subset <- .occup_db[.occup_db$Category %in% area_values, ]
      result[[percent_col]] <- (result[[occup_col]] / occup_db_subset$UTM_grids_10x10_Km[match(result[[area]], occup_db_subset$Category)]) * 100
    }

    result
  })

  names(result_list) <- paste0(output_name, "_", Scope_Area)

  if (length(Scope_Area) == 1) {
    return(result_list[[1]])
  } else {
    list2env(result_list, envir = .GlobalEnv)
  }
}





#Taxa Rich Graphs

#Primero leemos los archivos de las cuadrículas

.Shp_29 <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Grids_Zone_29")
.Shp_30 <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Grids_Zone_30")
.Shp_31 <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Grids_Zone_31")

.shp_list <- list(
  Shp_29 = .Shp_29,
  Shp_30 = .Shp_30,
  Shp_31 = .Shp_31
)


.Protected_Areas <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Parks_and_Reserves")

.mapa_celtic_fringe <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Celtic_Fringe")

.mapa_Subprovince <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Subprovinces")

.mapa_Country <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Countries")

.mapa_UK_Crown_dependencies <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "UK_Crown_dependencies")

.mapa_Admin_units_II <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Admin_units_II")

.mapa_Admin_units_III <- st_read(system.file("extdata", "ALL_MAPS_CIP_2025.gpkg", package = "CelticInvasivePlantsdb"), layer = "Admin_units_III")

.area_type_dict <- c(
  "UTM_grid" = "UTM_grid",
  "Subprovince" = "Subprovince",
  "Country" = "Country",
  "Admin_units_II" = "Admin_units_II",
  "Constituent_Country_OR_Crown_Dependency" = "Constituent_Country_OR_Crown_Dependency",
  "Admin_units_III" = "Admin_units_III",
  "Presence_Protected_Area" = "Presence_Protected_Area",
  "Presence_Natura_2000" = "Presence_Natura_2000",
  "Presence_National_Nature_Reserve" = "Presence_National_Nature_Reserve",
  "National_Nature_Reserve_Name" = "National_Nature_Reserve_Name",
  "Natura_2000_Name" = "Natura_2000_Name",
  "UNEP_WCMC_Cat" = "UNEP_WCMC_Cat",
  "IUCN_Cat" = "IUCN_Cat",
  "Special_Areas_of_Conservation_(Habitats_Directive)" = "Special_Areas_of_Conservation_(Habitats_Directive)",
  "Special_Protection_Area_(Birds_Directive)" = "Special_Protection_Area_(Birds_Directive)",
  "Site_of_Community_Importance_(Habitats_Directive)" = "Site_of_Community_Importance_(Habitats_Directive)"
)

#' @title UTM grids Taxa richness mapping (UTM_Rich_map)
#' @description  This function generate Taxa Richness maps (.png and .svg) with a 10x10 km UTM grid resolution .
#' @param 'data' argument must be the table obtained from Taxa_Rich_CIPdb().
#' @param 'Admin_Scope' allows to select data obtained using Taxa_Rich_CIPdb() function (= data object) based on administrative features of the grids. By default this is set to "ALL", which will not filter the data object. If the user wishes to filter this data 'Admin_Scope' input the must  be either a character string or a vector of character strings. This must a valid value within the following columns:"UTM_grid", "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency" and "Admin_units_III".
#' @param 'Area_type' allows a more accurate selection of the data object base on administrative features of the grids by selecting the column in which the user would like filter the data. By default this is set to "ALL", which will not select a column to filter the data object. The input of this argument must be one of the following character strings: "UTM_grid", "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency" and "Admin_units_III".
#' @param 'Title' this allows the user to assign a name for the output folder.
#' @param 'export_grids' this allows the user save shape files (.shp)  and their associated files of their taxa richness. By default this is set to FALSE and will not save the grids. If set to TRUE this will save the .shp with the grids of the selected area.
#' @param 'lines' argument allows to add administrative borders. By default this is set to "NULL", which will not add the administrative lines. The input of this argument must be one of the following character strings: "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency" and "Admin_units_III".
#' @param 'reserves' argument allows to add Natural reserves polygons.By default this is set to "NULL", which will not add the administrative lines. The input of this argument must be one of the following character strings: "Natura_2000" and "National_Parks".
#' @return  This function will create a map of taxa richness per "_richness" in the data object by  generating a folder in the users working directory (use pwd() to know the working directory and setwd() to set an specific working directory) with the name specify in the 'Title' argument where the maps will be stored as .png and .svg files. If export_grids = TRUE the shape file of the target grids will also be saved.
#' @details The optimal way of using this function is in combination with the  Select_CIPdb() or WDPA_PID_select_CIPdb() functions.
#' @seealso Taxa richness of Celtic Invasive Plants database or selections (Taxa_Rich_CIPdb) to learn how to obtain the taxa richness. We advise checking the unique values using the function for Conducting a value query within the  Celtic Invasive Plants database (CIP_value_query).
#' @examples
#'
#' #This provides the taxa richness of species, genera and families in the whole area with different lines
#' Data = CIPdb()
#' My_taxa_scope = c("Family", "Genus", "Species_with_Author")
#' My_tax_rich = Taxa_Rich_CIPdb(Data, My_taxa_scope , "UTM_grid")
#' UTM_Rich_map(My_tax_rich,  Title = "All Richness", export_grids = TRUE, lines = c("Subprovince") , reserves = c("Natura_2000", "National_Parks"))
#' UTM_Rich_map(My_tax_rich,  Title = "All Richness", export_grids = TRUE, lines = c("Subprovince", "UK_Crown_dependencies"))
#'
#'#This provides the taxa richness of species in the Wales and Scotland.
#' My_tax_rich = Taxa_Rich_CIPdb(Data, "Species_with_Author" , "UTM_grid")
#' UTM_Rich_map(My_tax_rich, Admin_Scope = c("Scotland", "Wales"), Area_type = "Constituent_Country_OR_Crown_Dependency", Title = "Scotland Wales Taxa Richness", lines = c("UK_Crown_dependencies"), export_grids = TRUE)
#'
#'#This provides the taxa richness of species in the French ATlantic subprovince
#' My_tax_rich = Taxa_Rich_CIPdb(Data, "Species_with_Author" , "UTM_grid")
#' UTM_Rich_map(My_tax_rich, Admin_Scope = "French Atlantic", Area_type = "Subprovince", Title = "French Atlantic Taxa Richness", reserves = c("Natura_2000", "National_Parks"),  export_grids = TRUE)
#'
#'
#'#This provides the taxa richness of species in the Asturias and Cantabria and export the grids shape files.
#'UTM_Rich_map(My_tax_rich, Admin_Scope = c("Asturias", "Cantabria"), Area_type = "Admin_units_III",
#'Title = "Asturias_Cantabria Richness", lines = c("Admin_units_II"), export_grids = TRUE)
#'UTM_Rich_map(My_tax_rich, Admin_Scope = c("Asturias", "Cantabria"),
#' Area_type = "Admin_units_III", Title = "Asturias_Cantabria Richness", lines = c("Admin_units_II"),
#'reserves = c("Natura_2000", "National_Parks"), export_grids = TRUE)
#'
#'#This provide the taxa richness of AIS in Picos de Europa (Spain)
#'My_selection <- Select_CIPdb(Data, "Picos de Europa", Officially_listed = "ALL",
#'Celtic_Fringe_Taxa_Category = "AIS")
#'My_tax_rich = Taxa_Rich_CIPdb(My_selection, "Species_with_Author" , "UTM_grid")
#'Picos = c("Picos de Europa", "Montaña de Riaño y Mampodre")
#'UTM_Rich_map(My_tax_rich, Admin_Scope = Picos, Area_type = "National_Nature_Reserve_Name",
#'Title = "Picos_Europa Richness", reserves = c("Natura_2000", "National_Parks"),  export_grids = FALSE)
#'
#' @export


UTM_Rich_map <- function(data, Admin_Scope = "ALL", Area_type = "ALL", Title = "Taxa_Richness", export_grids = FALSE, lines = NULL, reserves = NULL) {
  # Crear una carpeta para guardar los archivos
  output_dir <- file.path(getwd(), Title)
  dir.create(output_dir, showWarnings = FALSE)

  # Identificar las columnas que terminan en "_richness"
  richness_cols <- grep("_richness$", colnames(data), value = TRUE)
  if (length(richness_cols) == 0) {
    stop("The input data must have at least one '_richness' column")
  }

  # Seleccionar los shapefiles que contienen valores de UTM_grid de los datos
  utm_grids <- unique(data$UTM_grid)
  shp_list_filtered <- .shp_list[lapply(.shp_list, function(x) any(x$UTM_grid %in% utm_grids)) == TRUE]

  # Filtrar las cuadrículas según Admin_Scope
  if (any(Admin_Scope != "ALL")) {
    if (length(Admin_Scope) == 1) {
      Admin_Scope <- strsplit(Admin_Scope, ",")[[1]]
      Admin_Scope <- trimws(Admin_Scope)
    }
    Admin_Scope <- iconv(Admin_Scope, to = "ASCII//TRANSLIT")
    Admin_Scope <- tolower(Admin_Scope)
    shp_list_filtered <- lapply(shp_list_filtered, function(shp) {
      if (Area_type != "ALL") {
        if (!Area_type %in% names(.area_type_dict)) {
          stop(paste("Area_type value", Area_type, "not valid"))
        }
        real_area_type <- .area_type_dict[Area_type]
        shp_char <- shp[, real_area_type, drop = FALSE]
      } else {
        shp_char <- shp[, sapply(shp, is.character), drop = FALSE]
      }
      if (ncol(shp_char) > 0) {
        shp_char <- lapply(shp_char, function(x) {
          if (is.character(x)) {
            return(iconv(x, to = "ASCII//TRANSLIT"))
          } else {
            return(x)
          }
        })
        shp_char <- lapply(shp_char, tolower)
        filtered_shp <- shp[Reduce("|", lapply(shp_char, function(x) grepl(paste(Admin_Scope, collapse = "|"), x))), ]
      } else {
        filtered_shp <- shp
      }
      return(filtered_shp)
    })
    shp_list_filtered <- shp_list_filtered[sapply(shp_list_filtered, nrow) > 0]
  }

  # Calcular los límites de los shapefiles
  map_data <- lapply(shp_list_filtered, function(shp) {
    merge(shp, data[, c("UTM_grid", richness_cols[1])], by = "UTM_grid", all.x = TRUE)
  })

  # Transformar todos los objetos sf a un mismo CRS
  crs_target <- st_crs(map_data[[1]])
  map_data <- lapply(map_data, function(x) st_transform(x, crs_target))
  bbox <- st_bbox(do.call(rbind, map_data))

  # Crear el mapa
  mapa_base <- .mapa_celtic_fringe
  map_plot <- ggplot() +
    geom_sf(data = mapa_base, fill = "lightgray", color = "black")

  # Agregar los mapas de "lines"
  if (!is.null(lines)) {
    for (line in lines) {
      if (line %in% c("Subprovince", "Country", "Admin_units_II", "Admin_units_III", "UK_Crown_dependencies")) {
        mapa_line <- get(paste0(".mapa_", line))
      }
      map_plot <- map_plot + geom_sf(data = mapa_line, color = "black", fill = NA)
    }
  }

  # Agregar los mapas de "reserves"
  if (!is.null(reserves)) {
    for (reserve in reserves) {
      if (reserve == "Natura_2000") {
        mapa_reserve <- .Protected_Areas[.Protected_Areas$Natura_2000 == "Yes", ]
      } else if (reserve == "National_Parks") {
        mapa_reserve <- .Protected_Areas[.Protected_Areas$National_Nature_Reserve == "Yes", ]
      }
      print(nrow(mapa_reserve))  # Verifica que no esté vacío
      map_plot <- map_plot + geom_sf(data = mapa_reserve, color = "black", fill = "black", alpha = 0.5)
    }
  }

  # Crear los mapas de riqueza
  map_plots <- lapply(richness_cols, function(richness_col) {
    # Merge de los datos con los shapefiles
    map_data <- lapply(shp_list_filtered, function(shp) {
      merge(shp, data[, c("UTM_grid", richness_col)], by = "UTM_grid", all.x = TRUE)
    })

    # Transformar todos los objetos sf a un mismo CRS
    map_data <- lapply(map_data, function(x) st_transform(x, crs_target))

    # Crear el mapa
    map_plot_richness <- map_plot +
      lapply(map_data, function(x) {
        geom_sf(data = x, aes_string(fill = richness_col), alpha = 0.6)
      }) +
      scale_fill_viridis(option = "magma", direction = -1, na.value = "transparent") +
      labs(fill = richness_col, title = paste(Title, richness_col, sep = " - ")) +
      coord_sf(xlim = c(bbox$xmin, bbox$xmax), ylim = c(bbox$ymin, bbox$ymax)) +
      theme(
        panel.background = element_rect(fill = "lightblue")
      ) +
      annotation_north_arrow(location = "br", which_north = "true", pad_x = unit(0.1, "in"), pad_y = unit(0.4, "in"), height = unit(0.6, "cm"), width = unit(0.6, "cm")) +
      annotation_scale(location = "br", width_hint = 0.2, tick_height= 0.1)
    # Definir el nombre del mapa
    map_name <- paste0(Title, "_", richness_col)

    # Guardar el mapa como imagen
    ggsave(file.path(output_dir, paste0(map_name, ".png")), plot = map_plot_richness, width = 8, height = 6, dpi = 300)
    ggsave(file.path(output_dir, paste0(map_name, ".svg")), plot = map_plot_richness, width = 8, height = 6)

    # Asignar el mapa al global environment
    assign(map_name, map_plot_richness, envir = .GlobalEnv)

    # Exportar grids como shapefile
    if (export_grids) {
      export_data <- do.call(rbind, map_data)
      st_write(export_data, file.path(output_dir, paste0(map_name, "_grids.shp")), delete_layer = TRUE)
      # Asignar el archivo shapefile al global environment
      assign(paste0(map_name, "_grids"), export_data, envir = .GlobalEnv)
    }
    return(NULL)
  })
  return(NULL)
}





#Ahora protected areas
.mapa_National_Nature_Reserve_Name = .Protected_Areas[.Protected_Areas$National_Nature_Reserve %in% c("Yes"), ]
#Ahora renombreamos la columna SITENAME
.mapa_National_Nature_Reserve_Name = .mapa_National_Nature_Reserve_Name %>%
  rename(National_Nature_Reserve_Name = SITENAME)
#Agora selecionamos solu les colune de interés
.mapa_National_Nature_Reserve_Name <- .mapa_National_Nature_Reserve_Name %>%
  dplyr::select(
    National_Nature_Reserve_Name,
    geom
  )

#Facemos lu mesmu coles Natura_2000
.mapa_Natura_2000_Name = .Protected_Areas[.Protected_Areas$Natura_2000 %in% c("Yes"), ]

.mapa_Natura_2000_Name = .mapa_Natura_2000_Name %>%
  rename(Natura_2000_Name = SITENAME)
.mapa_Natura_2000_Name = .mapa_Natura_2000_Name %>%
  dplyr::select(
    Natura_2000_Name,
    geom
  )

#' @title Administrative units Taxa richness and  occupation mapping (Admin_Rich_Occup_map)
#' @description  This function generate Taxa Richness and Occupation maps (.png and .svg) with different administrative resolutions.
#' @param 'data' argument must be the table obtained from Taxa_Rich_CIPdb() or Taxa_Occup_CIPdb().
#' @param 'Representation_type' to specify the type of input data. By default this is set to "richness", which will work only with Taxa_Rich_CIPdb() data inputs. The input of this argument must be one of the following character strings: "richness" or 'occupation'. The latter will work with Taxa_Occup_CIPdb() data input.
#' @param 'Admin_Scope' allows to select data obtained using Taxa_Rich_CIPdb() function (= data object) based on administrative features of the grids. By default this is set to "Country", which will not filter the data object. If the user wishes to filter this data 'Admin_Scope' input the must  be either a character string or a vector of character strings. This must a valid value within the following columns:"UTM_grid", "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency", "Admin_units_III",  "National_Nature_Reserve_Name, and Natura_2000_Name.
#' @param 'Title' this allows the user to assign a name for the output folder.
#' @return  This function will create a map of taxa richness or occupation per "_richness" or "_occupation_percentage" column in the data object by  generating a folder in the users working directory (use pwd() to know the working directory and setwd() to set an specific working directory) with the name specify in the 'Title' argument where the maps will be stored as .png and .svg files.
#' @details The optimal way of using this function is in combination with the  Select_CIPdb() or WDPA_PID_select_CIPdb() functions.
#' @seealso Taxa richness of Celtic Invasive Plants database or selections (Taxa_Rich_CIPdb) and Taxa_Occup_CIPdb() to learn how to obtain the taxa richness and occupation. We advise checking the unique values using the function for Conducting a value query within the  Celtic Invasive Plants database (CIP_value_query).
#' @references
#' Maps:
#'European Environment Agency (EEA) (2017) Biogeographical regions in Europe. 2017. https://www.eea.europa.eu/data-and-maps/figures/biogeographical-regions-in-europe-2
#'Hijmans, R.J. (2025) geodata: Access Geographic Data. Version 0.6.6. 2025. CRAN.R-project.org. https://doi.org/10.32614/CRAN.package.geodata
#'
#' Protected areas details:
#'
#'European Environment Agency (EEA), 2025a. Emerald Network data (vector) - the Pan-European network of protected sites version 2024 https://doi.org/10.2909/135a0bb6-c611-4c2c-823d-a564be119ad8
#'European Environment Agency (EEA), 2024. Nationally designated areas for public access (vector data) - May 2024 https://doi.org/10.2909/616ef48f-7196-4e30-b201-6c97808fa68a
#'European Environment Agency (EEA), 2025b. Natura 2000 (tabular) - version end 2023 https://www.eea.europa.eu/en/datahub/datahubitem-view/6fc8ad2d-195d-40f4-bdec-576e7d1268e4
#' @examples
#'
#' #This provides a heatmap of the species richness of the French, Spain and Portugal at "Admin_units_II"
#' Data = CIPdb()
#' My_selection <- Select_CIPdb(Data, query = c("France", "Spain", "Portugal"))
#' My_taxa_scope = c("Family", "Genus", "Species_with_Author")
#' My_tax_rich = Taxa_Rich_CIPdb(My_selection, My_taxa_scope, "Admin_units_II")
#' Admin_Rich_Occup_map(My_tax_rich, Representation_type = "richness", Admin_Scope = "Admin_units_II", Title = "Taxa_Richness_Continent_Admin_II")
#'
#'#This provides a heatmap of  Cortaderia selloana occupation  of the French, Spain and Portugal at "Admin_units_II"
#' My_selection <- Select_CIPdb(Data,query = c("France", "Spain", "Portugal"))
#' my_species = Select_CIPdb(My_selection ,"Cortaderia selloana")
#' My_tax_occup = Taxa_Occup_CIPdb(my_species, "Species_with_Author", "Admin_units_II")
#' Admin_Rich_Occup_map(My_tax_occup, Representation_type = "occupation", Admin_Scope = "Admin_units_II", Title = "Cortaderia_selloana_Occupation_Continent_Admin_II")
#'
#' This provides a heatmap of the species richness of the French, Spain and Portugal at "Natura_2000_Name"
#' Data = CIPdb()
#' My_selection <- Select_CIPdb(Data, query = c("France", "Spain", "Portugal"))
#' My_taxa_scope = c("Family", "Genus", "Species_with_Author")
#' My_tax_rich = Taxa_Rich_CIPdb(My_selection, My_taxa_scope, "Natura_2000_Name")
#' Admin_Rich_Occup_map(My_tax_rich, Representation_type = "richness", Admin_Scope = "Natura_2000_Name", Title = "Taxa_Richness_Continent_Natura_2000_Name")
#'
#'
#'
#'

#' @export
Admin_Rich_Occup_map <- function(data, Representation_type = "richness", Admin_Scope = "Country", Title = "Taxa_Richness_Admin") {
  # Verificar que Representation_type sea válido
  if (!Representation_type %in% c("richness", "occupation")) {
    stop("Representation_type must be 'richness' or 'occupation'")
  }

  # Verificar que Admin_Scope sea válido
  if (!Admin_Scope %in% c("Subprovince", "Country", "Constituent_Country_OR_Crown_Dependency", "Admin_units_II", "Admin_units_III", "National_Nature_Reserve_Name", "Natura_2000_Name")) {
    stop("Admin_Scope value must be one of the following: 'Subprovince', 'Country', 'Constituent_Country_OR_Crown_Dependency', 'Admin_units_II', 'Admin_units_III', 'National_Nature_Reserve_Name', 'Natura_2000_Name'")
  }

  # Seleccionar el mapa según Admin_Scope
  mapa <- get(paste0(".mapa_", Admin_Scope))

  # Filtrar los datos según Admin_Scope
  mapa_filtrado <- mapa[mapa[[Admin_Scope]] %in% unique(data[[Admin_Scope]]), ]

  # Unir mapa_filtrado con data
  mapa_filtrado <- merge(mapa_filtrado, data, by = Admin_Scope)

  # Calcular el bbox
  bbox <- st_bbox(mapa_filtrado)

  # Seleccionar las columnas según Representation_type
  if (Representation_type == "richness") {
    cols <- grep("_richness$", colnames(data), value = TRUE)
  } else if (Representation_type == "occupation") {
    cols <- grep("_occupation_percentage$", colnames(data), value = TRUE)
  }

  # Crear un directorio para guardar los mapas
  output_dir <- file.path(getwd(), Title)
  dir.create(output_dir, showWarnings = FALSE)

  # Generar un mapa por cada columna
  for (col in cols) {
    # Crear el mapa base
    mapa_base <- .mapa_celtic_fringe

    # Establecer el color del borde según Admin_Scope
    if (Admin_Scope %in% c("National_Nature_Reserve_Name", "Natura_2000_Name")) {
      color_borde <- NA
    } else {
      color_borde <- "grey"
    }

    map_plot <- ggplot() +
      geom_sf(data = mapa_base, fill = "lightgray", color = "black") +
      geom_sf(data = mapa_filtrado, aes(fill = .data[[col]]), alpha = 0.6, color = color_borde) +
      scale_fill_viridis(option = "magma", direction = -1, na.value = "transparent") +
      coord_sf(xlim = c(bbox$xmin, bbox$xmax), ylim = c(bbox$ymin, bbox$ymax)) +
      theme(
        panel.background = element_rect(fill = "lightblue")
      ) +
      annotation_north_arrow(location = "br", which_north = "true", pad_x = unit(0.1, "in"), pad_y = unit(0.4, "in"), height = unit(0.6, "cm"), width = unit(0.6, "cm")) +
      annotation_scale(location = "br", width_hint = 0.2, tick_height= 0.1) +
      labs(title = paste(Title, col, sep = " - "), fill = col)

    # Definir el nombre del mapa
    map_name <- paste0(Title, "_", col)

    # Guardar el mapa como imagen
    ggsave(file.path(output_dir, paste0(map_name, ".png")), plot = map_plot, width = 8, height = 6, dpi = 300)
    ggsave(file.path(output_dir, paste0(map_name, ".svg")), plot = map_plot, width = 8, height = 6)

    # Asignar el mapa al global environment
    assign(map_name, map_plot, envir = .GlobalEnv)
  }
}


#' @title Taxa distribution mapping (Tax_Distribution_map)
#' @description  This function generate Taxa Distribution maps (.png and .svg) with a 10x10 km UTM grid resolution.
#' @param 'data' argument must be the table obtained from CIPdb() or another selection of this (Select_CIPdb, WDPA_PID_select_CIPdb).
#' @param 'query' argument allows to select the name or names of the taxa of interest. It must be either a character string or a vector of character strings specifying the term or terms of interest. This term must coincide with a value within the specified Scope_taxa (i.e. the value must be in the Scope_taxa column).
#' @param 'Taxa_Scope' argument allows to specify the taxa category of the query. It must be be either a character string or a vector of character strings. It must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author.
#' @param 'Admin_query' argument allows to select the name or names of the Administrative levels of interest. It must be be either a character string or a vector of character strings. It must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author.
#' @param 'Admin_Scope' allows to select the scope of administrative features of interest. By default this is set to "ALL", which will not filter the data object. If the user wishes to filter this data 'Admin_Scope' input the must  be either a character string or a vector of character strings. This must a valid value within the following columns:"UTM_grid", "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency" and "Admin_units_III".
#' @param 'Title' this allows the user to assign a name for the output folder.
#' @param 'export_grids' this allows the user save shape files (.shp)  and their associated files of their taxa richness. By default this is set to FALSE and will not save the grids. If set to TRUE this will save the .shp with the grids of the selected area.
#' @param 'lines' argument allows to add administrative borders. By default this is set to "NULL", which will not add the administrative lines. The input of this argument must be one of the following character strings: "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency" and "Admin_units_III".
#' @param 'reserves' argument allows to add Natural reserves polygons.By default this is set to "NULL", which will not add the administrative lines. The input of this argument must be one of the following character strings: "Natura_2000" and "National_Parks".
#' @return  This function will create a map of taxa distribution with 10x10 km UTM grid resolution a per "query" element  in the data object by  generating a folder in the users working directory (use pwd() to know the working directory and setwd() to set an specific working directory) with the name specify in the 'Title' argument where the maps will be stored as .png and .svg files. If export_grids = TRUE the shape file of the target grids will also be saved.
#' @examples
#'
#' #This provides distribution of Abutilon theophrasti and Phytolacca americana in the whole Celtic Fringe.
#' Data = CIPdb()
#'Tax_Distribution_map(Data, query = c("Abutilon theophrasti", "Phytolacca americana"), Title = "Taxa_Distribution", export_grids = FALSE)
#'
#'
#'#This provides distribution of the genus Acacia in the Spain and France representing the reserves as well
#'Tax_Distribution_map(Data, Taxa_Scope = "Genus", "Acacia", Admin_query = c("Spain", "France"), Admin_Scope = "Country", Title = "Acacia_Distribution", export_grids = FALSE, lines = c("Admin_units_II"), reserves = c("Natura_2000", "National_Parks"))
#'
#'#This provides distribution of the Angiosperms and Gymnosperms in the whole area.
#'Tax_Distribution_map(Data, Taxa_Scope = "Subphylum", "Gymnosperms", Title = "Gymno_Distribution", export_grids = FALSE)
#'
#'Tax_Distribution_map(Data, Taxa_Scope = "Subphylum", "Angiosperms ", Title = "Angio_Distribution", export_grids = FALSE)
#'
#'Tax_Distribution_map(Data, Taxa_Scope = "Subphylum", "Monilophyta", Title = "Felechu_Distribution", export_grids = FALSE)

#' @export


Tax_Distribution_map <- function(data, query, Taxa_Scope = "Taxa", Admin_query = "ALL", Admin_Scope = "ALL", Title = "Taxa_Distribution", export_grids = FALSE, lines = NULL, reserves = NULL) {
  # Crear una carpeta para guardar los archivos
  output_dir <- file.path(getwd(), Title)
  dir.create(output_dir, showWarnings = FALSE)

  # Loop sobre cada valor de query
  for (q in query) {
    # Filtrar los datos según el query
    data_filtered <- data[data[, Taxa_Scope] == q, ]

    # Seleccionar las UTM_grids en las que está presente el input de query
    utm_grids <- unique(data_filtered$UTM_grid)

    # Seleccionar los shapefiles que contienen valores de UTM_grid de los datos
    shp_list_filtered <- .shp_list[lapply(.shp_list, function(x) any(x$UTM_grid %in% utm_grids)) == TRUE]

    # Filtrar las cuadrículas según Admin_query
    if (any(Admin_query != "ALL")) {
      if (length(Admin_query) == 1) {
        Admin_query <- strsplit(Admin_query, ",")[[1]]
        Admin_query <- trimws(Admin_query)
      }
      Admin_query <- iconv(Admin_query, to = "ASCII//TRANSLIT")
      Admin_query <- tolower(Admin_query)
      shp_list_filtered <- lapply(shp_list_filtered, function(shp) {
        if (Admin_Scope != "ALL") {
          if (!Admin_Scope %in% names(.area_type_dict)) {
            stop(paste("Admin_Scope", Admin_Scope, "not valid"))
          }
          real_Admin_Scope <- .area_type_dict[Admin_Scope]
          shp_char <- shp[, real_Admin_Scope, drop = FALSE]
        } else {
          shp_char <- shp[, sapply(shp, is.character), drop = FALSE]
        }
        if (ncol(shp_char) > 0) {
          shp_char <- lapply(shp_char, function(x) {
            if (is.character(x)) {
              return(iconv(x, to = "ASCII//TRANSLIT"))
            } else {
              return(x)
            }
          })
          shp_char <- lapply(shp_char, tolower)
          filtered_shp <- shp[Reduce("|", lapply(shp_char, function(x) grepl(paste(Admin_query, collapse = "|"), x))), ]
        } else {
          filtered_shp <- shp
        }
        return(filtered_shp)
      })
      shp_list_filtered <- shp_list_filtered[sapply(shp_list_filtered, nrow) > 0]
    }

    # Crear el mapa de distribución
    crs_target <- st_crs(.shp_list[[1]])
    map_data <- lapply(shp_list_filtered, function(shp) {
      shp$Presente <- ifelse(shp$UTM_grid %in% utm_grids, "Presente", "No Presente")
      return(st_transform(shp, crs_target))
    })

    # Calcular el bbox
    all_shp <- lapply(.shp_list, function(x) st_transform(x, crs = crs_target))
    all_shp <- do.call(rbind, all_shp)
    bbox <- st_bbox(all_shp)

    # Crear el mapa
    mapa_base <- .mapa_celtic_fringe
    map_plot <- ggplot() +
      geom_sf(data = mapa_base, fill = "lightgray", color = "black")

    # Agregar los mapas de "lines"
    if (!is.null(lines)) {
      for (line in lines) {
        if (line %in% c("Subprovince", "Country", "Admin_units_II", "Admin_units_III", "UK_Crown_dependencies")) {
          mapa_line <- get(paste0(".mapa_", line))
        }
        map_plot <- map_plot + geom_sf(data = mapa_line, color = "black", fill = NA)
      }
    }

    # Agregar los mapas de "reserves"
    if (!is.null(reserves)) {
      for (reserve in reserves) {
        if (reserve == "Natura_2000") {
          mapa_reserve <- .Protected_Areas[.Protected_Areas$Natura_2000 == "Yes", ]
        } else if (reserve == "National_Parks") {
          mapa_reserve <- .Protected_Areas[.Protected_Areas$National_Nature_Reserve == "Yes", ]
        }
        print(nrow(mapa_reserve)) # Verifica que no esté vacío
        map_plot <- map_plot + geom_sf(data = mapa_reserve, color = "black", fill = "black", alpha = 0.5)
      }
    }

    # Crear el mapa
    map_plot <- map_plot +
      lapply(map_data, function(x) {
        geom_sf(data = x, aes(fill = Presente), alpha = 0.6)
      }) +
      scale_fill_manual(values = c("Presente" = "red", "No Presente" = "lightgray"), labels = c("Presente" = "Present", "No Presente" = "Not Present")) +
      labs(title = paste(Title, q, sep = " - ")) +
      coord_sf(xlim = c(bbox$xmin, bbox$xmax), ylim = c(bbox$ymin, bbox$ymax), crs = crs_target) +
      theme(
        panel.background = element_rect(fill = "lightblue")
      ) +
      annotation_north_arrow(location = "br", which_north = "true", pad_x = unit(0.1, "in"), pad_y = unit(0.4, "in"), height = unit(0.6, "cm"), width = unit(0.6, "cm")) +
      annotation_scale(location = "br", width_hint = 0.2, tick_height= 0.1)

    # Guardar el mapa como imagen
    map_name <- paste0(Title, "_", q)
    ggsave(file.path(output_dir, paste0(map_name, ".png")), plot = map_plot, width = 8, height = 6, dpi = 300)
    ggsave(file.path(output_dir, paste0(map_name, ".svg")), plot = map_plot, width = 8, height = 6)

    # Asignar el mapa al global environment
    assign(map_name, map_plot, envir = .GlobalEnv)

    # Exportar grids como shapefile
    if (export_grids) {
      export_data <- do.call(rbind, map_data)
      st_write(export_data, file.path(output_dir, paste0(map_name, "_grids.shp")), delete_layer = TRUE)
      # Asignar el archivo shapefile al global environment
      assign(paste0(map_name, "_grids"), export_data, envir = .GlobalEnv)
    }
  }
}

#' @title Taxa distribution mapping at admin levels (Tax_Distribution_Admin_map)
#' @description  This function generate Taxa Distribution maps (.png and .svg) with a UTM grid 10x10 km resolution.
#' @param 'data' argument must be the table obtained from CIPdb() or another selection of this (Select_CIPdb, WDPA_PID_select_CIPdb).
#' @param 'query' argument allows to select the name or names of the taxa of interest. It must be either a character string or a vector of character strings specifying the term or terms of interest. This term must coincide with a value within the specified Scope_taxa (i.e. the value must be in the Scope_taxa column).
#' @param 'Taxa_Scope' argument allows to specify the taxa category of the query. It must be be either a character string or a vector of character strings. It must be one of these: Phylum, Subphylum, Order, Family, Genus and Species_with_Author.
#' @param 'Admin_query' argument allows to select the name or names of the Administrative levels of interest. It must be be either a character string or a vector of character strings. The name must belong to only one of these categories: "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency","Admin_units_III", "Natura_2000" and "National_Parks".
#' @param 'Admin_Scope' argument allows to specify the taxa category of the query. It must be be either a character string or a vector of character strings. It must be one of these: "Subprovince", "Country", "Admin_units_II", "Constituent_Country_OR_Crown_Dependency","Admin_units_III", "Natura_2000" and "National_Parks".
#' @param 'Title' this allows the user to assign a name for the output folder.
#' @return  This function will create a map of taxa distribution  per "query" element in the data object with different administrative resolutions (depending on the 'Admin_Scope' value). It generates a folder in the users working directory (use pwd() to know the working directory and setwd() to set an specific working directory) with the name specify in the 'Title' argument where the maps will be stored as .png and .svg files.
#' @examples
#'
#' #This provides distribution of Abutilon theophrasti and Phytolacca americana in the whole Celtic Fringe.
#' Data = CIPdb()
#'Tax_Distribution_Admin_map(Data, query = c("Abutilon theophrasti", "Phytolacca americana"), Admin_query = "Natura_2000_Name", Admin_Scope = "Natura_2000_Name", Title = "Taxa_Distribution")
#'
#'
#'#This provides distribution of the genus Acacia in the Spain and France representing the reserves as well
#'Tax_Distribution_Admin_map(Data, Taxa_Scope = "Genus", "Acacia", Admin_query = c("Spain", "France"), Admin_Scope = "Country", Title = "Acacia_Distribution")
#'
#'
#'
#' @export



Tax_Distribution_Admin_map <- function(data, query, Taxa_Scope = "Taxa", Admin_query = "Country", Admin_Scope = "Country", Title = "Taxa_Distribution") {
  # Verificar que Admin_Scope sea válido
  if (!Admin_Scope %in% c("Subprovince", "Country", "Constituent_Country_OR_Crown_Dependency", "Admin_units_II", "Admin_units_III", "National_Nature_Reserve_Name", "Natura_2000_Name")) {
    stop("Admin_Scope value must be one of the following: 'Subprovince', 'Country', 'Constituent_Country_OR_Crown_Dependency', 'Admin_units_II', 'Admin_units_III', 'National_Nature_Reserve_Name', 'Natura_2000_Name'")
  }

  # Crear una carpeta para guardar los archivos
  output_dir <- file.path(getwd(), Title)
  dir.create(output_dir, showWarnings = FALSE)

  # Seleccionar el mapa según Admin_Scope
  mapa <- get(paste0(".mapa_", Admin_Scope))

  # Loop sobre cada valor de query
  for (q in query) {
    # Filtrar los datos según el query
    data_filtered <- data[data[, Taxa_Scope] == q, ]

    # Seleccionar los valores únicos de Admin_Scope
    admin_values <- unique(data_filtered[[Admin_Scope]])

    # Filtrar el mapa según los valores de Admin_Scope
    mapa_filtrado <- mapa[mapa[[Admin_Scope]] %in% admin_values, ]

    # Unir mapa_filtrado con data
    mapa_filtrado <- merge(mapa_filtrado, data_filtered, by = Admin_Scope)

    # Calcular el bbox
    bbox <- st_bbox(mapa_filtrado)

    # Crear el mapa de distribución
    crs_target <- st_crs(mapa_filtrado)
    map_data <- mapa_filtrado
    map_data$Presente <- ifelse(map_data[[Admin_Scope]] %in% admin_values, "Presente", "No Presente")
    #AHora los bordes
    if (Admin_Scope %in% c("National_Nature_Reserve_Name", "Natura_2000_Name")) {
      color_borde <- NA
    } else {
      color_borde <- "grey"
    }
    # Crear el mapa
    # Crear el mapa
    map_plot <- ggplot() +
      geom_sf(data = .mapa_celtic_fringe, fill = "lightgray", color = "black") +
      geom_sf(data = map_data, aes(fill = Presente), alpha = 0.6, color = color_borde) +
      scale_fill_manual(values = c("Presente" = "red", "No Presente" = "lightgray"), labels = c("Presente" = "Present", "No Presente" = "Not Present")) +
      labs(title = paste(Title, q, sep = " - ")) +
      coord_sf(xlim = c(bbox$xmin, bbox$xmax), ylim = c(bbox$ymin, bbox$ymax)) +
      theme(
        panel.background = element_rect(fill = "lightblue")
      ) +
      annotation_north_arrow(location = "br", which_north = "true", pad_x = unit(0.1, "in"), pad_y = unit(0.4, "in"), height = unit(0.6, "cm"), width = unit(0.6, "cm")) +
      annotation_scale(location = "br", width_hint = 0.2, tick_height= 0.1)

    # Guardar el mapa como imagen
    map_name <- paste0(Title, "_", q)
    ggsave(file.path(output_dir, paste0(map_name, ".png")), plot = map_plot, width = 8, height = 6, dpi = 300)
    ggsave(file.path(output_dir, paste0(map_name, ".svg")), plot = map_plot, width = 8, height = 6)

    # Asignar el mapa al global environment
    assign(map_name, map_plot, envir = .GlobalEnv)
  }
}
